zsyscall_linux_mips64le.go

func pipe(p *[2]_C_int,flags int) (err error) {
//      print("SYS_PIPE : ", SYS_PIPE, "\n")
        p0, p1, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)
        if e1 != 0 {
                err = errnoErr(e1)
        }
        p[0] = _C_int(p0)
        p[1] = _C_int(p1)
        print("pipe() p[0]: ", p[0], " p[1]: ", p[1], "\n")
        return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe2(p *[2]_C_int, flags int) (err error) {
        return ENOSYS
        _, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)
//print("pipe2() : error : ", e1, "\n")
        if e1 != 0 {
                err = errnoErr(e1)
        }
        return
}

syscall_linux_mips64x.go


func Pipe(p []int) (err error) {
/* borken - only works  > 2.6.27
        if len(p) != 2 {
                return EINVAL
        }
        var pp [2]_C_int
        err = pipe2(&pp, 0)
        p[0] = int(pp[0])
        p[1] = int(pp[1])
*/
        if len(p) != 2 {
                return EINVAL
        }
        var pp [2]_C_int
        err = pipe(&pp,0)
//print("Pipe() pp[0]: ", pp[0], " pp[1]: ", pp[1], "\n")
        p[0] = int(pp[0])
        p[1] = int(pp[1])
//print("Pipe() p[0]: ", p[0], " p[1]: ", p[1], "\n")
        return
}


arch_mips64le.go

const (
        TheChar       = '0'
        BigEndian     = 0
        CacheLineSize = 32
        PhysPageSize  = 65536
        PCQuantum     = 4
        Int64Align    = 8
        HugePageSize  = 0
        MinFrameSize  = 8
)


syscall/exec_linux.go

// Try to open a pipe with O_CLOEXEC set on both file descriptors.
func forkExecPipe(p []int) (err error) {
/*
        err = Pipe2(p, O_CLOEXEC)
*/
        // pipe2 was added in 2.6.27 and our minimum requirement is 2.6.23, so it
        // might not be implemented.
        err = ENOSYS
        if err == ENOSYS {
                if err = Pipe(p); err != nil {
                        return
                }
//print("forkExecPipe() - pipe ok : ", p[0], " : ", p[1], "\n")
                if _, err = fcntl(p[0], F_SETFD, FD_CLOEXEC); err != nil {
                        return
                }
//print("forkExecPipe() - fcntl0 ok : ", p[0], " : ", p[1], "\n")
                _, err = fcntl(p[1], F_SETFD, FD_CLOEXEC)
        }
//print("forkExecPipe() - fcntl1 ok : ", p[0], " : ", p[1], "\n")
        return
}

os/pipe_linux.go

// Pipe returns a connected pair of Files; reads from r return bytes written to w.
// It returns the files and an error, if any.
func Pipe() (r *File, w *File, err error) {
        var p [2]int

/*
        e := syscall.Pipe2(p[0:], syscall.O_CLOEXEC)
        // pipe2 was added in 2.6.27 and our minimum requirement is 2.6.23, so it
        // might not be implemented.
        if e == syscall.ENOSYS {
*/
                // See ../syscall/exec.go for description of lock.
                syscall.ForkLock.RLock()
                e := syscall.Pipe(p[0:])
                if e != nil {
print("pipe() failed\n")
                        syscall.ForkLock.RUnlock()
                        return nil, nil, NewSyscallError("pipe", e)
                }
print("pipe() succeeded\n")
                syscall.CloseOnExec(p[0])
                syscall.CloseOnExec(p[1])
                syscall.ForkLock.RUnlock()
/*
        } else if e != nil {
                return nil, nil, NewSyscallError("pipe2", e)
        }
*/

        f1 := NewFile(uintptr(p[0]), "|0")
        f2 := NewFile(uintptr(p[1]), "|1")

//      return NewFile(uintptr(p[0]), "|0"), NewFile(uintptr(p[1]), "|1"), nil
        return f1,f2,nil
}


